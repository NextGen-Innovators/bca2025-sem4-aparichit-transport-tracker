'use client';

import { useState, useEffect } from 'react';
import BookingPanel from '@/components/passenger/BookingPanel';
import SeatVisualizer from '@/components/passenger/SeatVisualizer';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Bus, Booking, VehicleTypeId } from '@/lib/types';
import { VEHICLE_TYPES } from '@/lib/constants';
import {
  MapPin,
  Ticket,
  Navigation,
  Clock,
  Smartphone,
  Users
} from 'lucide-react';
import { useAuth } from '@/lib/contexts/AuthContext';
import { useRouter } from 'next/navigation';
import MapWrapper from '@/components/map/MapWrapper';
import { subscribeToBuses, subscribeToBookings, updateBusLocation } from '@/lib/firebaseDb';
import { canAccommodateBooking } from '@/lib/seatManagement';
import { useToast } from '@/components/ui/use-toast';
import { checkProximity, haversineDistance, ProximityLevel } from '@/lib/utils/geofencing';
import { toast as sonnerToast } from 'sonner';
import { NotificationToast } from '@/components/shared/NotificationToast';
import DetailedBookingModal from '@/components/passenger/DetailedBookingModal';
import { subscribeToBusLocation } from '@/lib/firebaseDb';
import { calculateETA, formatETA, formatDistance } from '@/lib/utils/etaCalculator';
import LocationSearch from '@/components/map/LocationSearch';
import { Skeleton } from '@/components/ui/skeleton';

export default function PassengerDashboard() {
  const router = useRouter();
  const { currentUser, role, loading, signOut } = useAuth();
  const { toast } = useToast();
  const [buses, setBuses] = useState<Bus[]>([]);
  const [selectedBus, setSelectedBus] = useState<Bus | null>(null);
  const [pickupLocation, setPickupLocation] = useState<{ lat: number; lng: number; address?: string } | null>(null);
  const [dropoffLocation, setDropoffLocation] = useState<{ lat: number; lng: number; address?: string } | null>(null);
  const [bookings, setBookings] = useState<Booking[]>([]);
  const [vehicleFilter, setVehicleFilter] = useState<VehicleTypeId | 'all'>('all');
  const [bookingLoading, setBookingLoading] = useState(false);
  const [pickupProximityLevel, setPickupProximityLevel] = useState<ProximityLevel | null>(null);
  const [lastNotificationByBooking, setLastNotificationByBooking] = useState<
    Record<string, ProximityLevel | null>
  >({});
  const [notificationsEnabled, setNotificationsEnabled] = useState<boolean>(() => {
    if (typeof window === 'undefined') return true;
    const stored = window.localStorage.getItem('notificationsEnabled');
    return stored ? stored === 'true' : true;
  });
  const [vibrationEnabled, setVibrationEnabled] = useState<boolean>(() => {
    if (typeof window === 'undefined') return true;
    const stored = window.localStorage.getItem('vibrationEnabled');
    return stored ? stored === 'true' : true;
  });
  const [hasRequestedNotificationPermission, setHasRequestedNotificationPermission] =
    useState(false);

  const [userLocation, setUserLocation] = useState<{ lat: number; lng: number } | null>(null);
  const [busLocations, setBusLocations] = useState<Record<string, {
    lat: number;
    lng: number;
    timestamp: string;
    heading?: number;
    speed?: number;
  }>>({});
  const [busETAs, setBusETAs] = useState<Record<string, number | null>>({});

  // Get user's current location
  useEffect(() => {
    if (!navigator.geolocation) return;

    const watchId = navigator.geolocation.watchPosition(
      (position) => {
        setUserLocation({
          lat: position.coords.latitude,
          lng: position.coords.longitude,
        });

        // Auto-set pickup to current location if not set
        setPickupLocation(prev => prev ? prev : {
          lat: position.coords.latitude,
          lng: position.coords.longitude,
          address: 'Current Location'
        });
      },
      (error) => {
        console.warn('Geolocation error:', error);
        let errorMessage = "Unknown error acquiring position";
        switch (error.code) {
          case 1: errorMessage = "Location permission denied. Please enable it in settings."; break;
          case 2: errorMessage = "Location unavailable. Check your GPS or network."; break;
          case 3: errorMessage = "Location request timed out."; break;
        }

        // Only show toast once per session or if critical
        if (!userLocation) {
          toast({
            title: "Location Error",
            description: errorMessage + " Using default location.",
            variant: "destructive"
          });
          // Fallback to Kathmandu (or a safe default) so map works
          setUserLocation({ lat: 27.7172, lng: 85.3240 });
        }
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 10000
      }
    );

    return () => navigator.geolocation.clearWatch(watchId);
  }, []);

  // Subscribe to real-time bus updates
  useEffect(() => {
    const unsubscribe = subscribeToBuses((busesData) => {
      // Parse Location timestamps properly
      const parsedBuses = busesData.map(bus => {
        if (bus.currentLocation) {
          // Handle both Date objects and ISO strings
          const timestamp = bus.currentLocation.timestamp instanceof Date
            ? bus.currentLocation.timestamp
            : typeof bus.currentLocation.timestamp === 'string'
              ? new Date(bus.currentLocation.timestamp)
              : new Date();

          return {
            ...bus,
            currentLocation: {
              ...bus.currentLocation,
              timestamp,
            },
          };
        }
        return bus;
      });
      setBuses(parsedBuses);
    });
    return () => unsubscribe();
  }, []);

  // Subscribe to real-time location updates for each active bus
  // We use a stable key for buses to prevent infinite loops when updating bus locations
  const activeBusIds = buses.filter(b => b.isActive).map(b => b.id).join(',');

  useEffect(() => {
    // eslint-disable-next-line no-console
    console.log('[PASSENGER] Setting up location listeners for active buses');

    const unsubscribes: (() => void)[] = [];

    buses.forEach(bus => {
      if (bus.isActive) {
        // eslint-disable-next-line no-console
        console.log('[PASSENGER] Subscribing to bus location:', bus.id);

        const unsubscribe = subscribeToBusLocation(bus.id, (location) => {
          if (location) {
            setBusLocations(prev => ({
              ...prev,
              [bus.id]: location,
            }));

            // Calculate ETA only if user location is available AND this is the selected bus
            if (userLocation && selectedBus && selectedBus.id === bus.id) {
              const eta = calculateETA(
                { lat: location.lat, lng: location.lng },
                userLocation,
                location.speed || 30
              );
              setBusETAs(prev => ({
                ...prev,
                [bus.id]: eta,
              }));
            }
          }
        });
        unsubscribes.push(unsubscribe);
      }
    });

    return () => {
      // eslint-disable-next-line no-console
      console.log('[PASSENGER] Cleaning up location listeners');
      unsubscribes.forEach(unsub => unsub());
    };
    // Only re-subscribe if the set of active buses changes, or if userLocation/selectedBus changes (for ETA)
    // We intentionally omit 'buses' to avoid the infinite loop caused by setBuses updating the dependency
  }, [activeBusIds, userLocation, selectedBus?.id]);

  // Update bus locations in buses array when real-time updates arrive
  useEffect(() => {
    if (Object.keys(busLocations).length === 0) return;

    setBuses(prevBuses => {
      const updated = prevBuses.map(bus => {
        const locationUpdate = busLocations[bus.id];
        if (locationUpdate) {
          // Only update if location actually changed
          const currentLat = bus.currentLocation?.lat || 0;
          const currentLng = bus.currentLocation?.lng || 0;
          if (Math.abs(currentLat - locationUpdate.lat) > 0.00001 ||
            Math.abs(currentLng - locationUpdate.lng) > 0.00001) {
            return {
              ...bus,
              currentLocation: {
                ...(bus.currentLocation || {}),
                lat: locationUpdate.lat,
                lng: locationUpdate.lng,
                timestamp: new Date(locationUpdate.timestamp),
              } as any, // Cast to avoid strict type issues with optional
            };
          }
        }
        return bus;
      });
      return updated;
    });
  }, [busLocations]);

  // Subscribe to this passenger's bookings in real-time
  useEffect(() => {
    if (!currentUser) return;

    const unsubscribe = subscribeToBookings(currentUser.uid, 'passenger', (list) => {
      const mapped = list.map((b) => ({
        ...b,
        timestamp: new Date(b.timestamp),
        pickupLocation: {
          ...b.pickupLocation,
          timestamp: new Date(b.pickupLocation.timestamp),
        },
        dropoffLocation: {
          ...b.dropoffLocation,
          timestamp: new Date(b.dropoffLocation.timestamp),
        },
        reservationExpiresAt: b.reservationExpiresAt
          ? new Date(b.reservationExpiresAt)
          : undefined,
      })) as Booking[];

      setBookings(mapped);
    });

    return () => unsubscribe();
  }, [currentUser]);

  // Request browser notification permission once when notifications are enabled
  useEffect(() => {
    if (typeof window === 'undefined') return;
    if (!notificationsEnabled) return;
    if (hasRequestedNotificationPermission) return;
    if (!('Notification' in window)) return;

    if (Notification.permission === 'default') {
      Notification.requestPermission().finally(() => {
        setHasRequestedNotificationPermission(true);
      });
    } else {
      setHasRequestedNotificationPermission(true);
    }
  }, [notificationsEnabled, hasRequestedNotificationPermission]);

  // Persist notification settings
  useEffect(() => {
    if (typeof window === 'undefined') return;
    window.localStorage.setItem('notificationsEnabled', String(notificationsEnabled));
  }, [notificationsEnabled]);

  useEffect(() => {
    if (typeof window === 'undefined') return;
    window.localStorage.setItem('vibrationEnabled', String(vibrationEnabled));
  }, [vibrationEnabled]);

  // Proximity detection every 10 seconds for active bookings
  useEffect(() => {
    if (!notificationsEnabled) return;
    if (bookings.length === 0) return;

    const intervalId = window.setInterval(() => {
      // Focus on bookings that are pending or confirmed
      const activeBookings = bookings.filter((b) =>
        ['pending', 'confirmed'].includes(b.status)
      );
      if (activeBookings.length === 0) return;

      let highestLevel: ProximityLevel | null = null;

      activeBookings.forEach((booking) => {
        const bus = buses.find((b) => b.id === booking.busId && b.isActive);
        if (!bus || !booking.pickupLocation || !bus.currentLocation) return;

        const level = checkProximity(
          bus.currentLocation,
          booking.pickupLocation
        );
        if (!level) return;

        const distanceMeters = haversineDistance(
          bus.currentLocation.lat,
          bus.currentLocation.lng,
          booking.pickupLocation.lat,
          booking.pickupLocation.lng
        );

        // Track highest proximity level for map highlighting
        const levelPriority: Record<ProximityLevel, number> = {
          far: 0,
          approaching: 1,
          nearby: 2,
          arrived: 3,
        };

        if (!highestLevel || levelPriority[level] > levelPriority[highestLevel]) {
          highestLevel = level;
        }

        const lastLevel = lastNotificationByBooking[booking.id] ?? null;
        if (lastLevel === level) {
          return; // avoid duplicate notifications for same level
        }

        // Prepare vibration pattern (guarded)
        const vibrate = (pattern: number | number[]) => {
          if (!vibrationEnabled) return;
          if (typeof window === 'undefined') return;
          if (!('vibrate' in window.navigator)) return;
          try {
            window.navigator.vibrate(pattern);
          } catch {
            // ignore vibration errors
          }
        };

        // Show proximity notification using sonner
        if (level === 'approaching') {
          sonnerToast.custom(
            (id) => (
              <NotificationToast
                title="Bus approaching your area ðŸšŒ"
                message="Your bus is getting closer to your pickup point."
                distanceMeters={distanceMeters}
                onViewMap={() => {
                  setSelectedBus(bus);
                  sonnerToast.dismiss(id);
                }}
              />
            ),
            { duration: 5000 }
          );
        } else if (level === 'nearby') {
          vibrate(200);
          sonnerToast.custom(
            (id) => (
              <NotificationToast
                title="Bus is nearby! ðŸ””"
                message="Get ready to board, your bus is very close."
                distanceMeters={distanceMeters}
                onViewMap={() => {
                  setSelectedBus(bus);
                  sonnerToast.dismiss(id);
                }}
              />
            ),
            { duration: 5000 }
          );
        } else if (level === 'arrived') {
          vibrate([200, 100, 200, 100, 200]);
          sonnerToast.custom(
            (id) => (
              <NotificationToast
                title="Bus arriving NOW! ðŸŽ‰"
                message="Your bus has reached your pickup location."
                distanceMeters={distanceMeters}
                onViewMap={() => {
                  setSelectedBus(bus);
                  sonnerToast.dismiss(id);
                }}
              />
            ),
            { duration: 5000 }
          );
        }

        setLastNotificationByBooking((prev) => ({
          ...prev,
          [booking.id]: level,
        }));
      });

      setPickupProximityLevel(highestLevel);
    }, 10000);

    return () => {
      window.clearInterval(intervalId);
    };
  }, [
    bookings,
    buses,
    notificationsEnabled,
    vibrationEnabled,
    lastNotificationByBooking,
  ]);

  const handleBookBus = async (bus: Bus, bookingData?: any) => {
    if (!pickupLocation) {
      toast({
        title: 'Select pickup location first',
        description: 'Please select pickup location on the map or use your current location.',
        variant: 'destructive',
      });
      return;
    }

    // For hailing, use pickup location as dropoff if not set
    const finalDropoffLocation = dropoffLocation || pickupLocation;

    // Check if bus can accommodate the booking
    const numberOfPassengers = bookingData?.numberOfPassengers || 1;
    if (!canAccommodateBooking(bus, numberOfPassengers)) {
      toast({
        title: 'Not enough seats available',
        description: `This bus only has ${bus.availableSeats} seats available. You requested ${numberOfPassengers}.`,
        variant: 'destructive',
      });
      return;
    }

    try {
      setBookingLoading(true);

      const response = await fetch('/api/bookings/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          bookingData: {
            busId: bus.id,
            passengerName: bookingData?.passengerName || 'Passenger',
            phoneNumber: bookingData?.phoneNumber || 'N/A',
            email: bookingData?.email || '',
            pickupLocation: {
              ...pickupLocation,
              address: pickupLocation.address || 'Pickup Location',
            },
            dropoffLocation: {
              ...finalDropoffLocation,
              address: finalDropoffLocation.address || (dropoffLocation ? 'Dropoff Location' : 'Same as Pickup'),
            },
            numberOfPassengers,
            notes: bookingData?.notes || '',
            paymentMethod: bookingData?.paymentMethod || 'cash',
            vehicleType: bus.vehicleType,
            status: bookingData?.status || 'pending',
          },
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data?.error || 'Failed to create booking');
      }

      const created = data.booking as Booking;

      const bookingWithDate: Booking = {
        ...created,
        timestamp: new Date(created.timestamp),
        pickupLocation: {
          ...created.pickupLocation,
          timestamp: new Date(created.pickupLocation.timestamp),
        },
        dropoffLocation: {
          ...created.dropoffLocation,
          timestamp: new Date(created.dropoffLocation.timestamp),
        },
        reservationExpiresAt: created.reservationExpiresAt
          ? new Date(created.reservationExpiresAt)
          : undefined,
      } as Booking;

      setBookings((prev) => [...prev, bookingWithDate]);
      setSelectedBus(null);
      setPickupLocation(null);
      setDropoffLocation(null);

      toast({
        title: 'Booking confirmed',
        description: `You have successfully booked ${bus.busNumber}.`,
      });
    } catch (error) {
      console.error('Booking error:', error);
      const message =
        error instanceof Error ? error.message : 'Failed to create booking. Please try again.';
      toast({
        title: 'Booking failed',
        description: message,
        variant: 'destructive',
      });
    } finally {
      setBookingLoading(false);
    }
  };

  const handleLocationSelect = (location: { lat: number; lng: number }) => {
    // Simple address generation for demo
    const address = `Location (${location.lat.toFixed(4)}, ${location.lng.toFixed(4)})`;

    if (!pickupLocation) {
      setPickupLocation({ ...location, address });
    } else if (!dropoffLocation) {
      setDropoffLocation({ ...location, address });
    } else {
      setPickupLocation({ ...location, address });
      setDropoffLocation(null);
    }
  };

  const handleResetLocations = () => {
    setPickupLocation(null);
    setDropoffLocation(null);
  };

  const filteredBuses = buses.filter((bus) =>
    vehicleFilter === 'all' ? bus.isActive : (bus.isActive && bus.vehicleType === vehicleFilter)
  );

  // Auth guard
  useEffect(() => {
    if (!loading) {
      if (!currentUser) {
        router.replace('/auth?redirect=/passenger');
      } else if (role && role !== 'passenger') {
        router.replace('/driver');
      }
    }
  }, [currentUser, role, loading, router]);

  if (loading || !currentUser || (role && role !== 'passenger')) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-950 via-blue-950 to-slate-950 flex flex-col">
        {/* Skeleton Header */}
        <div className="h-16 border-b border-slate-800 bg-slate-950/80 p-4 flex items-center justify-between">
          <div className="flex items-center gap-3">
            <Skeleton className="w-8 h-8 rounded-full" />
            <div className="space-y-1">
              <Skeleton className="w-24 h-4" />
              <Skeleton className="w-16 h-3" />
            </div>
          </div>
          <Skeleton className="w-9 h-9 rounded-full" />
        </div>

        {/* Skeleton Map */}
        <div className="w-full h-[65vh] relative bg-slate-900">
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="text-center">
              <div className="relative w-20 h-20 mx-auto mb-6">
                <div className="absolute inset-0 bg-cyan-500/20 rounded-full animate-ping"></div>
                <div className="relative bg-gradient-to-br from-cyan-500 to-blue-600 rounded-2xl w-full h-full flex items-center justify-center shadow-2xl shadow-cyan-500/50">
                  <Navigation className="w-10 h-10 text-white animate-pulse" />
                </div>
              </div>
              <p className="text-slate-400 text-lg font-medium">Locating nearby buses...</p>
            </div>
          </div>
        </div>

        {/* Skeleton Content */}
        <div className="flex-1 p-4 space-y-4">
          <Skeleton className="w-32 h-6" />
          <Skeleton className="w-full h-32 rounded-xl" />
        </div>
      </div>
    );
  }

  // --- UI Render ---
  return (
    <div className="min-h-screen bg-slate-950 flex flex-col">
      {/* 1. Header (Sticky Top) */}
      <div className="sticky top-0 z-50 bg-slate-950/80 backdrop-blur-xl border-b border-slate-800 p-4">
        <div className="flex items-center justify-between gap-4">
          {/* Left: Brand */}
          <div className="flex items-center gap-3">
            <div className="w-8 h-8 rounded-full bg-gradient-to-br from-purple-500 to-blue-600 flex items-center justify-center shadow-lg shadow-purple-500/30">
              <Navigation className="w-4 h-4 text-white" />
            </div>
            <div>
              <h1 className="text-sm font-black text-white tracking-tight leading-none">
                BusTracker
              </h1>
              <div className="flex items-center gap-1.5 mt-0.5">
                <span className="w-1.5 h-1.5 rounded-full bg-green-500 animate-pulse"></span>
                <span className="text-[10px] text-slate-300 font-medium">
                  {buses.filter(b => b.isActive).length} Active
                </span>
              </div>
            </div>
          </div>

          {/* Right: Actions */}
          <div className="flex items-center gap-2">
            <DetailedBookingModal />

            {/* Sign Out Button */}
            <Button
              variant="ghost"
              onClick={signOut}
              size="icon"
              className="w-9 h-9 rounded-full bg-slate-900/50 border border-slate-700/50 text-red-400 hover:text-red-300 hover:bg-red-500/10"
            >
              <span className="sr-only">Sign Out</span>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              >
                <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" />
                <polyline points="16 17 21 12 16 7" />
                <line x1="21" x2="9" y1="12" y2="12" />
              </svg>
            </Button>
          </div>
        </div>

        {/* Search Bar (Mobile/Desktop) */}
        <div className="mt-4 px-1">
          <LocationSearch
            onLocationSelect={handleLocationSelect}
            placeholder="Search destination or pickup..."
          />
        </div>

        {/* Filters Row */}
        <div className="mt-4 flex items-center gap-2 overflow-x-auto no-scrollbar pb-1">
          <Button
            size="sm"
            variant={vehicleFilter === 'all' ? 'default' : 'secondary'}
            className={`h-7 rounded-full text-xs border ${vehicleFilter === 'all'
              ? 'bg-slate-800 border-slate-600 text-white'
              : 'bg-slate-900/50 text-slate-400 border-slate-800 hover:bg-slate-800'}`}
            onClick={() => setVehicleFilter('all')}
          >
            All
          </Button>
          {VEHICLE_TYPES.map(type => (
            <Button
              key={type.id}
              size="sm"
              variant={vehicleFilter === type.id ? 'default' : 'secondary'}
              className={`h-7 rounded-full text-xs border flex items-center gap-1.5 ${vehicleFilter === type.id
                ? 'bg-slate-800 border-slate-600 text-white'
                : 'bg-slate-900/50 text-slate-400 border-slate-800 hover:bg-slate-800'}`}
              onClick={() => setVehicleFilter(type.id)}
            >
              <span>{type.icon}</span>
              <span>{type.name}</span>
            </Button>
          ))}
        </div>
      </div>

      {/* 2. Map Section (Priority View) */}
      <div className="relative w-full h-[65vh] shrink-0 border-b border-slate-800">
        <MapWrapper
          role="passenger"
          buses={filteredBuses}
          selectedBus={selectedBus}
          onBusSelect={setSelectedBus}
          onLocationSelect={handleLocationSelect}
          showRoute={!!selectedBus}
          pickupLocation={pickupLocation}
          dropoffLocation={dropoffLocation}
          pickupProximityLevel={pickupProximityLevel}
          userLocation={userLocation}
          busETAs={busETAs}
          busLocations={busLocations}
        />

        {/* Floating Action Button for Hailing (Overlaid on Map) */}
        {selectedBus && !pickupLocation && (
          <div className="absolute bottom-4 left-4 right-4 z-[400] animate-in slide-in-from-bottom-4 fade-in duration-300">
            <Button
              className="w-full h-12 rounded-xl bg-emerald-500 hover:bg-emerald-600 text-white font-bold shadow-lg shadow-emerald-500/30 flex items-center justify-center gap-2"
              onClick={() => {
                if (userLocation) {
                  setPickupLocation({
                    lat: userLocation.lat,
                    lng: userLocation.lng,
                    address: 'Current Location'
                  });
                } else {
                  toast({ title: "Waiting for location...", variant: "default" });
                }
              }}
            >
              <Navigation className="w-5 h-5 fill-current" />
              HAIL {selectedBus.busNumber} NOW
            </Button>
          </div>
        )}
      </div>

      {/* 3. Scrollable Content (Below Map) */}
      <div className="flex-1 bg-slate-950 p-4 space-y-6">
        {/* Booking Panel */}
        <div className="space-y-2">
          <h2 className="text-lg font-bold text-white flex items-center gap-2">
            <Ticket className="w-5 h-5 text-blue-400" />
            Ride Details
          </h2>
          <BookingPanel
            pickupLocation={pickupLocation}
            dropoffLocation={dropoffLocation}
            selectedBus={selectedBus}
            onBook={handleBookBus}
            onReset={handleResetLocations}
            loading={bookingLoading}
          />
        </div>

        {/* Instructions / Tips */}
        {!selectedBus && (
          <div className="grid grid-cols-3 gap-3">
            <div className="bg-slate-900/50 border border-slate-800 p-3 rounded-xl flex flex-col items-center text-center gap-2">
              <div className="w-8 h-8 rounded-full bg-blue-500/10 flex items-center justify-center">
                <MapPin className="w-4 h-4 text-blue-400" />
              </div>
              <span className="text-xs font-medium text-slate-400">1. Tap Bus</span>
            </div>
            <div className="bg-slate-900/50 border border-slate-800 p-3 rounded-xl flex flex-col items-center text-center gap-2">
              <div className="w-8 h-8 rounded-full bg-emerald-500/10 flex items-center justify-center">
                <Navigation className="w-4 h-4 text-emerald-400" />
              </div>
              <span className="text-xs font-medium text-slate-400">2. Hail</span>
            </div>
            <div className="bg-slate-900/50 border border-slate-800 p-3 rounded-xl flex flex-col items-center text-center gap-2">
              <div className="w-8 h-8 rounded-full bg-purple-500/10 flex items-center justify-center">
                <Clock className="w-4 h-4 text-purple-400" />
              </div>
              <span className="text-xs font-medium text-slate-400">3. Ride</span>
            </div>
          </div>
        )}

        {/* Bottom Padding for scrolling */}
        <div className="h-8"></div>
      </div>
    </div>
  );
}
